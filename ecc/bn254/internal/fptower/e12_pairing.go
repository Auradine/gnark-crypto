package fptower

func (z *E12) nSquare(n int) {
	for i := 0; i < n; i++ {
		z.CyclotomicSquare(z)
	}
}

func (z *E12) nSquareCompressed(n int) {
	for i := 0; i < n; i++ {
		z.CyclotomicSquareCompressed(z)
	}
}

// Expt set z to xᵗ (mod q¹²) and return z (t is the generator of the curve)
func (z *E12) Expt(x *E12) *E12 {
	// FixedExp computation is derived from the addition chain:
	//
	//	_10       = 2*1
	//	_11       = 1 + _10
	//	_100      = 1 + _11
	//	_110      = _10 + _100
	//	_1100     = 2*_110
	//	_1111     = _11 + _1100
	//	_10010    = _11 + _1111
	//	_10110    = _100 + _10010
	//	_11100    = _110 + _10110
	//	_101110   = _10010 + _11100
	//	_1001010  = _11100 + _101110
	//	_1111000  = _101110 + _1001010
	//	_10001110 = _10110 + _1111000
	//	i15       = 2*_10001110 + _1001010
	//	i16       = _10001110 + i15
	//	i17       = _1111 + i16
	//	i18       = i16 + i17
	//	i20       = 2*i18 + i17
	//	i21       = _1111000 + i20
	//	i22       = i15 + i21
	//	i26       = i22 << 2 + i22 + i18
	//	i27       = i22 + i26
	//	i61       = ((i26 + i27) << 17 + i27) << 14 + i21
	//	return      i61 << 16 + i20
	//
	// Operations: 53 squares 25 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var result, t0, t1, t2, t3 E12

	// Step 1: z = x^0x2
	result.CyclotomicSquare(x)

	// Step 2: t0 = x^0x3
	t0.Mul(x, &result)

	// Step 3: t2 = x^0x4
	t2.Mul(x, &t0)

	// Step 4: t1 = x^0x6
	t1.Mul(&result, &t2)

	// Step 5: z = x^0xc
	result.CyclotomicSquare(&t1)

	// Step 6: z = x^0xf
	result.Mul(&t0, &result)

	// Step 7: t0 = x^0x12
	t0.Mul(&t0, &result)

	// Step 8: t2 = x^0x16
	t2.Mul(&t2, &t0)

	// Step 9: t1 = x^0x1c
	t1.Mul(&t1, &t2)

	// Step 10: t0 = x^0x2e
	t0.Mul(&t0, &t1)

	// Step 11: t1 = x^0x4a
	t1.Mul(&t1, &t0)

	// Step 12: t0 = x^0x78
	t0.Mul(&t0, &t1)

	// Step 13: t2 = x^0x8e
	t2.Mul(&t2, &t0)

	// Step 14: t3 = x^0x11c
	t3.CyclotomicSquare(&t2)

	// Step 15: t1 = x^0x166
	t1.Mul(&t1, &t3)

	// Step 16: t2 = x^0x1f4
	t2.Mul(&t2, &t1)

	// Step 17: z = x^0x203
	result.Mul(&result, &t2)

	// Step 18: t2 = x^0x3f7
	t2.Mul(&t2, &result)

	// Step 19: t3 = x^0x7ee
	t3.CyclotomicSquare(&t2)

	// Step 20: z = x^0x9f1
	result.Mul(&result, &t3)

	// Step 21: t0 = x^0xa69
	t0.Mul(&t0, &result)

	// Step 22: t1 = x^0xbcf
	t1.Mul(&t1, &t0)

	// Step 24: t3 = x^0x2f3c
	t3.CyclotomicSquare(&t1)
	t3.CyclotomicSquare(&t3)

	// Step 25: t3 = x^0x3b0b
	t3.Mul(&t1, &t3)

	// Step 26: t2 = x^0x3f02
	t2.Mul(&t2, &t3)

	// Step 27: t1 = x^0x4ad1
	t1.Mul(&t1, &t2)

	// Step 28: t2 = x^0x89d3
	t2.Mul(&t2, &t1)

	// Step 45: t2 = x^0x113a60000
	t2.nSquareCompressed(17)
	t2.DecompressKarabina(&t2)

	// Step 46: t1 = x^0x113a64ad1
	t1.Mul(&t1, &t2)

	// Step 60: t1 = x^0x44e992b44000
	t1.nSquareCompressed(14)
	t1.DecompressKarabina(&t1)

	// Step 61: t0 = x^0x44e992b44a69
	t0.Mul(&t0, &t1)

	// Step 77: t0 = x^0x44e992b44a690000
	t0.nSquareCompressed(16)
	t0.DecompressKarabina(&t0)

	// Step 78: z = x^0x44e992b44a6909f1
	z.Mul(&result, &t0)

	return z
}

// MulBy034 multiplication by sparse element (c0,0,0,c3,c4,0)
func (z *E12) MulBy034(c0, c3, c4 *E2) *E12 {

	var a, b, d E6

	a.MulByE2(&z.C0, c0)

	b.Set(&z.C1)
	b.MulBy01(c3, c4)

	c0.Add(c0, c3)
	d.Add(&z.C0, &z.C1)
	d.MulBy01(c0, c4)

	z.C1.Add(&a, &b).Neg(&z.C1).Add(&z.C1, &d)
	z.C0.MulByNonResidue(&b).Add(&z.C0, &a)

	return z
}

// Mul034By034 multiplication of sparse element (c0,0,0,c3,c4,0) by sparse element (d0,0,0,d3,d4,0)
func (z *E12) Mul034by034(d0, d3, d4, c0, c3, c4 *E2) *E12 {
	var tmp, x0, x3, x4, x04, x03, x34 E2
	x0.Mul(c0, d0)
	x3.Mul(c3, d3)
	x4.Mul(c4, d4)
	tmp.Add(c0, c4)
	x04.Add(d0, d4).
		Mul(&x04, &tmp).
		Sub(&x04, &x0).
		Sub(&x04, &x4)
	tmp.Add(c0, c3)
	x03.Add(d0, d3).
		Mul(&x03, &tmp).
		Sub(&x03, &x0).
		Sub(&x03, &x3)
	tmp.Add(c3, c4)
	x34.Add(d3, d4).
		Mul(&x34, &tmp).
		Sub(&x34, &x3).
		Sub(&x34, &x4)

	z.C0.B0.MulByNonResidue(&x4).
		Add(&z.C0.B0, &x0)
	z.C0.B1.Set(&x3)
	z.C0.B2.Set(&x34)
	z.C1.B0.Set(&x03)
	z.C1.B1.Set(&x04)
	z.C1.B2.SetZero()

	return z
}
